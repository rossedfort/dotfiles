#!/usr/bin/env bash

PROMPT_COMMAND=__prompt_command

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
  export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
  export TERM='xterm-256color';
fi;

__prompt_command() {
  # set local variable to hold last command's exit status
  local EXIT="$?"
  PS1=""
  # Setup some color variables
  reset="\e[0m";
  default="\e[39m";
  # Normal
  black="\e[30m";
  red="\e[31m";
  green="\e[32m";
  yellow="\e[33m";
  blue="\e[34m";
  magenta="\e[35m";
  cyan="\e[36m";
  # Bright
  bright_red="\e[1;31m";
  bright_green="\e[1;32m";
  bright_yellow="\e[1;33m";
  bright_blue="\e[1;34m";
  bright_magenta="\e[1;35m";
  bright_cyan="\e[1;36m";

  if [ $EXIT -eq 0 ]; then
    exitStyle="${green}✓";
  else
    exitStyle="${red}✗";
  fi

  PS1+="${red}\u${reset} at ${yellow}\h${reset} in ${green}\w${reset}$(git_info)${reset} ${exitStyle}${reset}\n$ ";
  export PS1;
  PS2="${cyan}→ ${reset}";
  export PS2;
}

git_info() {
  [ -x "$(which git)" ] || return # git not found

  local git_eng="env LANG=C git" # force git output in English to make our work easier
  # get current branch name or short SHA1 hash for detached head
  local branch="$($git_eng symbolic-ref --short HEAD 2>/dev/null || $git_eng describe --tags --always 2>/dev/null)"
  [ -n "$branch" ] || return # git branch not found

  local marks='';

  # is branch modified?
  [ -n "$($git_eng status --porcelain)" ] && marks+=" △ "

  # how many commits local branch is ahead/behind of remote?
  local stat="$($git_eng status --porcelain --branch | grep '^##' | grep -o '\[.\+\]$')"
  local aheadN="$(echo $stat | grep -o 'ahead [[:digit:]]\+' | grep -o '[[:digit:]]\+')"
  local behindN="$(echo $stat | grep -o 'behind [[:digit:]]\+' | grep -o '[[:digit:]]\+')"
  [ -n "$aheadN" ] && marks+=" ↑$aheadN"
  [ -n "$behindN" ] && marks+=" ↓$behindN"

  echo -e " on ${blue}(${branch})${magenta}${marks}";
}
